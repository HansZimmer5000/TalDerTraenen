Offene Fragen:
    - Was bedeuten die Variablen?
        ArbeitsZeit -> Delay zwischen Jetzt und der Zeit wenn der ggT-Prozess anfangen soll zu arbeiten
        TermZeit    -> 
        GGTProAnz   -> Anzahl an ggT-Prozessen
        GGTProName  -> Name des ggT-Prozesses
        CMi     -> Client Mi
        CZeit   -> Client Zeit des abschickens
        LCMi    -> 
        WggT    -> Wunsch ggT
        LeftN   -> Node links des aktuellen (Im Kreis, Uhrzeigersinn)
        RightN  -> Node rechts des aktuellen (Im Kreis, Gegen den Uhrzeigersinn)
        MiNeu   -> Neues Mi für gewissen ggT-Prozess
        Quota   -> 
    - Was ist die "Abstimmung"?
    - Warum hat Koordinator manchmal eine Response auf {briefterm, ...} vom Starter oder ggT-Prozess?


Geschlossene Fragen:
    - Was machen die Koordinator aufrufe:
        step    -> Übergang von Sammeln der ggT-Prozess hellos zum errichten des Kreises
        prompt  -> ("Antreiben") ggT-Prozesse auffordern aktuellen Mi zurück zu schicken.
        nudge   -> ("Anstupsen") Anpingen, pong zurück erwarten
        toggle  -> ("Umschalten")
    - Wie sieht der GGTProName aus?
        "GGT-" + StarterNummer + Praktikumsgruppennummer + Teamnummer + ggT-Prozess Nummer (von 1 bis GGTProAnz).
    - Was ist das 2. Argument bei starter:go?
        Nummer des Starters
    - Wofür ist koordinator genau zuständig?
        Verwaltet die ggT-Prozesse
    - Wofür ist starter genau zuständig?
        Er startet alle ggT-Prozesse (noch ohne Mis)
    - Sind Initial nur Nummern eingegeben die auch alle einen ggT haben?
        Macht dann koordinator mit vsutil:bestimme_mis/2 + verschicken der Mis an die ggT-Prozesse
    - Wofür ist nameservice genau zuständig?
        Managen der prozess + nodenamen auf prozess Ids, wie ein DNS.
    - Wie erkennt man die Terminierung?
        Alle haben die selbe Zahl, den Wunsch ggT (WggT), oder wenn die Zahlen nicht zusammenpassen (z.b. 27, 4) und nichts mehr geht.
    - Welche Startnummern haben die Prozesse?
        Die von der Folie oder eben selbst ausdenken.
    - Was passiert wenn Y == X bzw. Y > X?
        Keine Zahl verändert sich, keine Nachricht wird aufgrund dessen geschickt.
        Der Prozess der durch einkommendes Y nicht verändert wird logt "Teminierung mit ggT XY".
    - Warum hört das Programm auf zu Arbeiten (Beispiel 1, Folien)? 
        Weil keine Zahl im letzten Schritt verändert wurde -> keine Nachricht geschickt wurde.
    - Wo steht das Ergebnis?
        Theoretisch in allen Prozessen mit Mi, der ja dann dem ggT entspricht.
    - Warum wird eine Nummer per Hand gesendet (Beispiel 2, Folien)?
        Weil das System sonst nicht weiterrechnet.
    - Warum steht bei Koordinator in den Folien ggT-Prozess und manchmal nicht?
        Weil manchmal auch der ggT-Prozess diese Calls verstehen muss.
    - Warum steht bei Starter in den Folien ggT-Prozess?
        Weil der ggT-Prozess die Calls auch verstehen muss.

Ablauf:
    INITIAL
    nameservice:start()     nameservice wird gestartet.
    koordinator:start()     koordinator wird gestartet und meldet sich beim nameservice an.
                            ?NAMESERVICE ! {self(), {rebind, KoName, KoNode}}
    starter:go(Anzahl, StarterNummer) starter wird gestartet
                            fordert vom koordinator {self(), getsteeringval} an.
                            GoValues weiter geben an zu startende definierte Anzahl ggT-Prozesse
                            GoValues = {ArbeitsZeit, TermZeit, GGTProName, Quota}
    ggT-Prozess             meldet sich beim nameservice an,
                            ?NAMESERVICE ! {self(), {rebind, Clientname, self()}}
                            sagt dem koordinator hallo
                            {hello, GGTProName}
    koordinator             wartet auf alle ggT-Prozesse, bis "step" kommmt, dann wird der Kreis gebaut.
                            ?NAMESERVICE ! {self(), {lookup, GGTProName}}
                            ggT-Prozess ! {setneighbors, LeftNode, RightNode}

    CALCULATION
    anwender        schickt an koordinator {calc, WggT}
    koordinator     bekommt {calc, WggT}, 
                    ruft vsutil:bestimme_mis/2 auf 
                    und verteilt Mis and ggT-Prozesse {setpm, MiNeu}
                    __??__ (WIE?) Initiiert Berechnung
    ggT-Prozess     Warten auf empfang von {setpm, MiNeu} -> Mi setzen.
                    Warten auf empfang von {sendy, Y} -> Formel ausführen
                    Wenn NeuMi <> Mi -> an Nachbarn schicken
    koordinator     Sollte das System noch nicht am WggT angekommen sein,
                    muss der anwender den koordinator bescheid geben es anzustoßen.
                    __??__ (WIE?)

    VOTING
    __??__ (WIE?)
    

Eigentlich wichtige Formel:
    ggT(x,0) = x
    ggT(x,x) = x
    ggT(x,y) = ggT(y, mod(x,y))

Hier verwendet (Verteilte) Version:
    - Ein Prozess "Pi" hat eine Nummer "Mi"
    - "Mi" wird behandelt wie x.
    - Die eingesendete Nummer ist y.
    if y < Mi
        then Mi = mod(Mi - 1, y) + 1
            send Mi to all neighbours - Eine Art Rekursivität

Komponenten:
    nameservice     - Verwaltet die Prozess- und Nodenamen und bildet auf Prozessids ab.
        NamesToPids: Liste aus Namen & Pid Tupeln {NameXY, {RegisteredName, Node}}
    koordinator     - Verwaltet die ggT-Prozesse (manuelle Kommandos, ggT-Prozessnachbarn, logging)
    starter         - Startet die ggT-Prozesse, noch ohne Mi.
    ggT-Prozess     - Hat ein Mi und kennt ggT-Formel, berechnet eigentliches Ergebnis, den ggT.

API:
    nameservice
        (vom koordinator, ggT-Process)
        {AbsenderPid, {bind, Name, node()}} -> ok | in_use
        {AbsenderPid, {rebind, Name, node()}} -> ok
        {AbsenderPid, {lookup, Name}} -> {pin, {Name, Node}} | not_found
        {AbsenderPid, {unbind, Name}} -> ok
        {AbsenderPid, {multicast, vote, MeinName}} -> {AbsenderPid, {vote, MeinName}} (I guess, an alle ggT-Prozesse + koordinator?)
        {AbsenderPid, reset} -> ok

    koordinator
        (vom starter & ggT-Prozess)
        {AbsenderPid, getsteeringval} -> {steeringval, ArbeitsZeit, TermZeit, Quota, GGTProAnz}
        {hello, GGTProName} -> none
        {briefmi, {GGTProName, CMi, CZeit}} -> none
        {AbsenderPid, briefterm, {GGTProName, CMi, CZeit}} -> {sendy, LCMi}
        {pongGGT, GGTProName} -> none (Antwort auf Ping)
        {mi, Mi} -> none (Antwort auf tellmi über prompt)

        (manuell)
        reset -> none
        step -> none
        {calc, WggT} -> none
        prompt -> none
        nudge -> none
        toggle -> none
        kill -> none

    starter & ggT-Prozess
        (vom koordinator & ggT-Prozess)
        {steeringval, ArbeitsZeit, TermZeit, Quota, GGTProAnz} -> none
        {setneighbors, LeftN, RightN} -> none 
        {setpm, MiNeu} -> none
        {sendy, Y} -> {sendy, MiNeu}
        {voteYes, GGTProName} -> none
        {AbsenderPid, tellmi} -> {mi, Mi}
        {AbsenderPid, pingGGT} -> {pongGGT, GGTProName}
        kill -> none

