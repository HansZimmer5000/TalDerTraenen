Offene Fragen:
    - Sind Initial nur Nummern eingegeben die auch alle einen ggT haben?
    - Wofür ist nameservice genau zuständig?
    - Wofür ist koordinator genau zuständig?
    - Wofür ist start_starter genau zuständig?
    - Warum wird beim start gesagt dass der start_starter mit dem nameservice spricht?
        Aber später nicht mehr aufgeführt und der start_starter nur mit dem koordinator spricht?
    - Was bedeuten die Variablen?
        ArbeitsZeit ->
        TermZeit    ->
        GGTProAnz   ->
        GGTProName  ->
        CMi     -> Client Mi
        CZeit   -> Client Zeit, Zeit des abschickens
        LCMi    ->
        WggT    ->    
        LeftN   -> Node links des aktuellen (Im Kreis, Uhrzeigersinn)
        RightN  -> Node rechts des aktuellen (Im Kreis, Gegen den Uhrzeigersinn)
        MiNeu   -> 
        Initiator   -> 
    - Warum steht bei Koordinator in den Folien ggT-Prozess und manchmal nicht?
    - Warum steht bei Starter in den Folien ggT-Prozess?
    - Was ist die "Abstimmung"?
    - Warum hat Koordinator manchmal eine Response auf {briefterm, ...} vom Starter?





Geschlossene Fragen:
    - Wie erkennt man die Terminierung?
        Alle haben die selbe Zahl, oder wenn die Zahlen nicht zusammenpassen (z.b. 27, 4) und nichts mehr geht.
    - Welche Startnummern haben die Prozesse?
        Die von der Folie oder eben selbst ausdenken.
    - Wie genau wird die erste Nummer gesendet?
        Durch {abstimmung, Initiator} Nachricht vom koordinator zum start_starter
    - Was passiert wenn Y == X bzw. Y > X?
        Keine Zahl verändert sich, keine Nachricht wird aufgrund dessen geschickt.
        Der Prozess der durch einkommendes Y nicht verändert wird logt "Teminierung mit ggT XY".
    - Warum hört das Programm auf zu Arbeiten (Beispiel 1, Folien)? 
        Weil keine Zahl im letzten Schritt verändert wurde -> keine Nachricht geschickt wurde.
    - Wo steht das Ergebnis?
        Theoretisch in allen Prozessen mit Mi, der ja dann dem ggT entspricht.
    - Warum wird eine Nummer per Hand gesendet (Beispiel 2, Folien)?
        Weil das System sonst nicht weiterrechnet.

Ablauf:
    nameservice:start()     nameservice wird gestartet.
    koordinator:start()     koordinator wird gestartet und meldet sich beim nameservice an.
                            ?NAMESERVICE ! {self(), {rebind, KoName, KoNode}}
    start_starter:go(Anzahl, Start) start_starter wird gestartet und meldet sich beim nameservice an.
                            ?NAMESERVICE ! {self(), {rebind, Clientname, self()}} 
                            XOR (Was ist richtig?)
                            meldet sich beim koordinator an.
    koordinator             bekommt {}

Eigentlich wichtige Formel:
    ggT(x,0) = x
    ggT(x,x) = x
    ggT(x,y) = ggT(y, mod(x,y))

Hier verwendet (Verteilte) Version:
    - Ein Prozess "Pi" hat eine Nummer "Mi"
    - "Mi" wird behandelt wie x.
    - Die eingesendete Nummer ist y.
    if y < Mi
        then Mi = mod(Mi - 1, y) + 1
            send Mi to all neighbours - Eine Art Rekursivität

Komponenten:
    nameservice

    koordinator

    start_starter

API:
    nameservice
        (vom koordinator)
        {AbsenderPid, {bind, Name, node()}} -> ok | in_use
        {AbsenderPid, {rebind, Name, node()}} -> ok
        {AbsenderPid, {lookup, Name}} -> {pin, {Name, Node}} | not_found
        {AbsenderPid, {unbind, Name}} -> ok

    koordinator
        (vom start_starter)
        {getsteeringval, AbsenderPid} -> {steeringval, ArbeitsZeit, TermZeit, GGTProAnz}
        {hello, GGTProName} -> none
        {briefmi, {GGTProName, CMi, CZeit}} -> none
        {briefterm, {GGTProName, CMi, CZeit}, AbsenderPid} -> {sendy, LCMi}

        (manuell)
        reset -> none
        step -> none
        {calc, WggT} -> none
        prompt -> none
        nudge -> none
        toggle -> none
        kill -> none

    start_starter
        (vom koordinator)
        {steeringval, ArbeitsZeit, TermZeit, GGTProAnz} -> none
        {setneighbors, LeftN, RightN} -> none (MISPELLING?)
        {setpm, MiNeu} -> none
        {sendy, Y} -> {sendy, MiNeu}
        {abstimmung, Initiator} -> {abstimmung, Initiator}
        {tellmi, AbsenderPid} -> {mi, Mi}
        {pingGGT, AbsenderPid} -> {pongGGT, GGTProName}
        none -> {briefmi, {GGTProName, CMi, CZeit}}
        none -> {briefterm, {GGTProName, CMi, CZeit}, self()}
        kill -> none

